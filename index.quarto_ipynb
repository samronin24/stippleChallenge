{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Selection Bias & Missing Data Challenge - Part 1\"\n",
        "subtitle: \"Blue Noise Stippling: Creating Art from Data\"\n",
        "format:\n",
        "  html: default\n",
        "execute:\n",
        "  echo: true\n",
        "  eval: true\n",
        "---\n",
        "\n",
        "# ðŸŽ¨ Selection Bias & Missing Data Challenge - Part 1\n",
        "\n",
        "::: {.callout-important}\n",
        "## ðŸ“Š Challenge Requirements\n",
        "\n",
        "**Your Task:** Reproduce the blue noise stippling process demonstrated below to create:\n",
        "1. A stippled version of your chosen image\n",
        "2. A progressive stippling GIF animation\n",
        "3. Post both to a GitHub Pages site with appropriate captions and a brief explanation\n",
        "\n",
        "**Part 2 Preview:** On November 18th, we'll tackle Part 2 of this challenge, where you'll create a statistical meme about selection bias and missing data using your stippled images.\n",
        ":::\n",
        "\n",
        "## The Problem: Can Algorithms Create Art?\n",
        "\n",
        "**Core Question:** How can we convert a photograph into an aesthetically pleasing pattern of dots that preserves the visual information of the original image?\n",
        "\n",
        "**The Challenge:** Blue noise stippling is a technique that converts images into patterns of dots (stipples) using algorithms that balance visual accuracy with spatial distribution. This challenge asks you to implement a modified \"void and cluster\" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed.\n",
        "\n",
        "**Our Approach:** We'll use a modified void-and-cluster algorithm that:\n",
        "1. Creates an importance map identifying visually important regions\n",
        "2. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties\n",
        "3. Iteratively selects points with minimum energy\n",
        "4. Balances image content importance with blue noise spatial distribution\n",
        "\n",
        "\n",
        "## Introduction to Blue Noise Stippling\n",
        "\n",
        "Blue noise stippling is a technique for converting images into a pattern of dots (stipples) that preserves the visual information of the original image while creating an aesthetically pleasing, evenly distributed pattern. This method follows the approach described by [Bart Wronski](https://bartwronski.com/2022/08/31/progressive-image-stippling-and-greedy-blue-noise-importance-sampling/).\n",
        "\n",
        "The method uses a modified \"void and cluster\" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed. This version uses **smooth extreme downweighting** that selectively downweights very dark and very light tones while preserving mid-tones, creating a more balanced distribution of stipples across the image.\n",
        "\n",
        "## Loading the Original Image\n",
        "\n",
        "First, let's load an image that we'll convert to a blue noise stippling pattern. You can use any image you'd like, but we'll demonstrate with the provided example.\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "374e852e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: load-image\n",
        "#| echo: true\n",
        "#| fig-cap: Original image before stippling\n",
        "\n",
        "import numpy as np\n",
        "from PIL import Image\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Load the image\n",
        "img_path = 'sam_headshot.jpg'\n",
        "original_img = Image.open(img_path)\n",
        "\n",
        "# Convert to grayscale if needed\n",
        "if original_img.mode != 'L':\n",
        "    original_img = original_img.convert('L')\n",
        "\n",
        "# Convert to numpy array and normalize to [0, 1]\n",
        "img_array = np.array(original_img, dtype=np.float32) / 255.0\n",
        "\n",
        "# Display the original image\n",
        "fig, ax = plt.subplots(figsize=(6.5, 5))\n",
        "ax.imshow(img_array, cmap='gray', vmin=0, vmax=1)\n",
        "ax.axis('off')\n",
        "ax.set_title('Original Image', fontsize=14, fontweight='bold', pad=10)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "print(f\"Image shape: {img_array.shape}\")\n",
        "print(f\"Image size: {img_array.shape[0]}x{img_array.shape[1]} pixels\")"
      ],
      "id": "load-image",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Make sure the headshot you want to stipple is saved in the project directory as `sam_headshot.jpg` (keep the `.jpg` extension, or adjust `img_path` to whatever filename you choose).\n",
        "\n",
        "::::\n",
        "\n",
        "## Importance Mapping\n",
        "\n",
        "Before applying the stippling algorithm, we create an **importance map** that identifies which regions of the image should receive more stipples. The importance map is computed by:\n",
        "\n",
        "- **Brightness inversion**: The image brightness is inverted so that dark areas receive higher importance and thus more dots, while light areas receive fewer dots\n",
        "- **Extreme tone downweighting**: Smooth Gaussian functions downweight tones below 0.2 (very dark) and above 0.8 (very light), creating a gradual transition that preserves mid-tones\n",
        "- **Mid-tone boost**: A smooth Gaussian function centered on mid-tones provides a gradual increase in importance for mid-tone regions, ensuring they receive appropriate stippling density\n",
        "- **Selective and effective**: This approach ensures that stipples are distributed appropriately (more dots in dark areas and mid-tones, fewer in extreme dark/light areas) while maintaining good spatial distribution\n",
        "\n",
        ":::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "19b91be6"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: importance-map\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "def compute_importance(\n",
        "    gray_img: np.ndarray,\n",
        "    extreme_downweight: float = 0.5,\n",
        "    extreme_threshold_low: float = 0.4,\n",
        "    extreme_threshold_high: float = 0.8,\n",
        "    extreme_sigma: float = 0.1,\n",
        "    mid_tone_boost: float = 0.4,\n",
        "    mid_tone_sigma: float = 0.2,\n",
        "):\n",
        "    \"\"\"\n",
        "    Importance map computation that downweights extreme tones (very dark and very light)\n",
        "    using smooth functions, while boosting mid-tones.\n",
        "    \n",
        "    Parameters\n",
        "    ----------\n",
        "    gray_img : np.ndarray\n",
        "        Grayscale image in [0, 1]\n",
        "    extreme_downweight : float\n",
        "        Strength of downweighting for extreme tones (0.0 = no downweighting, 1.0 = maximum downweighting)\n",
        "    extreme_threshold_low : float\n",
        "        Threshold below which tones are considered \"very dark\" and get downweighted\n",
        "    extreme_threshold_high : float\n",
        "        Threshold above which tones are considered \"very light\" and get downweighted\n",
        "    extreme_sigma : float\n",
        "        Width of the smooth transition for extreme downweighting (smaller = sharper transition)\n",
        "    mid_tone_boost : float\n",
        "        Strength of mid-tone emphasis (0.0 = no boost, 1.0 = strong boost)\n",
        "    mid_tone_sigma : float\n",
        "        Width of the mid-tone Gaussian bump (smaller = narrower, larger = wider)\n",
        "    \n",
        "    Returns\n",
        "    -------\n",
        "    importance : np.ndarray\n",
        "        Importance map in [0, 1]; higher = more stipples (dark areas and mid-tones get higher importance)\n",
        "    \"\"\"\n",
        "    I = np.clip(gray_img, 0.0, 1.0)\n",
        "    \n",
        "    # Invert brightness: dark areas should get more dots (higher importance)\n",
        "    I_inverted = 1.0 - I\n",
        "    \n",
        "    # Create smooth downweighting mask for extreme tones\n",
        "    # Downweight very dark regions (I < extreme_threshold_low)\n",
        "    dark_mask = np.exp(-((I - 0.0) ** 2) / (2.0 * (extreme_sigma ** 2)))\n",
        "    dark_mask = np.where(I < extreme_threshold_low, dark_mask, 0.0)\n",
        "    if dark_mask.max() > 0:\n",
        "        dark_mask = dark_mask / dark_mask.max()\n",
        "    \n",
        "    # Downweight very light regions (I > extreme_threshold_high)\n",
        "    light_mask = np.exp(-((I - 1.0) ** 2) / (2.0 * (extreme_sigma ** 2)))\n",
        "    light_mask = np.where(I > extreme_threshold_high, light_mask, 0.0)\n",
        "    if light_mask.max() > 0:\n",
        "        light_mask = light_mask / light_mask.max()\n",
        "    \n",
        "    # Combine both masks\n",
        "    extreme_mask = np.maximum(dark_mask, light_mask)\n",
        "    \n",
        "    # Apply smooth downweighting\n",
        "    importance = I_inverted * (1.0 - extreme_downweight * extreme_mask)\n",
        "    \n",
        "    # Add smooth gradual mid-tone boost (Gaussian centered on 0.65)\n",
        "    mid_tone_center = 0.65\n",
        "    mid_tone_gaussian = np.exp(-((I - mid_tone_center) ** 2) / (2.0 * (mid_tone_sigma ** 2)))\n",
        "    if mid_tone_gaussian.max() > 0:\n",
        "        mid_tone_gaussian = mid_tone_gaussian / mid_tone_gaussian.max()\n",
        "    \n",
        "    # Boost importance in mid-tone regions\n",
        "    importance = importance * (1.0 + mid_tone_boost * mid_tone_gaussian)\n",
        "    \n",
        "    # Normalize to [0,1]\n",
        "    m, M = importance.min(), importance.max()\n",
        "    if M > m: \n",
        "        importance = (importance - m) / (M - m)\n",
        "    return importance"
      ],
      "id": "importance-map",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Blue Noise Stippling Algorithm\n",
        "\n",
        "The stippling algorithm uses a modified void-and-cluster approach that:\n",
        "\n",
        "1. Creates an importance map that identifies visually important regions\n",
        "2. Initializes an energy field based on the importance map (higher importance â†’ lower energy)\n",
        "3. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties\n",
        "4. Iteratively selects points with minimum energy\n",
        "5. Adds Gaussian \"splats\" around selected points to prevent clustering\n",
        "6. Balances image content importance with blue noise spatial distribution\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "d84edfed"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: stippling-functions\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import numpy as np\n",
        "\n",
        "def toroidal_gaussian_kernel(h: int, w: int, sigma: float):\n",
        "    \"\"\"\n",
        "    Create a periodic (toroidal) 2D Gaussian kernel centered at (0,0).\n",
        "    The toroidal property means the kernel wraps around at the edges,\n",
        "    ensuring consistent repulsion behavior regardless of point location.\n",
        "    \"\"\"\n",
        "    y = np.arange(h)\n",
        "    x = np.arange(w)\n",
        "    # Compute toroidal distances (minimum distance considering wrapping)\n",
        "    dy = np.minimum(y, h - y)[:, None]\n",
        "    dx = np.minimum(x, w - x)[None, :]\n",
        "    # Compute Gaussian\n",
        "    kern = np.exp(-(dx**2 + dy**2) / (2.0 * sigma**2))\n",
        "    s = kern.sum()\n",
        "    if s > 0:\n",
        "        kern /= s  # Normalize\n",
        "    return kern\n",
        "\n",
        "\n",
        "def void_and_cluster(\n",
        "    input_img: np.ndarray,\n",
        "    percentage: float = 0.08,\n",
        "    sigma: float = 0.9,\n",
        "    content_bias: float = 0.9,\n",
        "    importance_img: np.ndarray | None = None,\n",
        "    noise_scale_factor: float = 0.1,\n",
        "):\n",
        "    \"\"\"\n",
        "    Generate blue noise stippling pattern from input image using a modified\n",
        "    void-and-cluster algorithm with content-weighted importance.\n",
        "    \"\"\"\n",
        "    I = np.clip(input_img, 0.0, 1.0)\n",
        "    h, w = I.shape\n",
        "\n",
        "    # Compute or use provided importance map\n",
        "    if importance_img is None:\n",
        "        importance = compute_importance(I)\n",
        "    else:\n",
        "        importance = np.clip(importance_img, 0.0, 1.0)\n",
        "\n",
        "    # Create toroidal Gaussian kernel for repulsion\n",
        "    kernel = toroidal_gaussian_kernel(h, w, sigma)\n",
        "\n",
        "    # Initialize energy field: lower energy â†’ more likely to be picked\n",
        "    energy_current = -importance * content_bias\n",
        "\n",
        "    # Stipple buffer: start with white background; selected points become black dots\n",
        "    final_stipple = np.ones_like(I)\n",
        "    samples = []\n",
        "\n",
        "    # Helper function to roll kernel to an arbitrary position\n",
        "    def energy_splat(y, x):\n",
        "        \"\"\"Get energy contribution by rolling the kernel to position (y, x).\"\"\"\n",
        "        return np.roll(np.roll(kernel, shift=y, axis=0), shift=x, axis=1)\n",
        "\n",
        "    # Number of points to select\n",
        "    num_points = int(I.size * percentage)\n",
        "\n",
        "    # Choose first point near center with minimal energy\n",
        "    cy, cx = h // 2, w // 2\n",
        "    r = min(20, h // 10, w // 10)\n",
        "    ys = slice(max(0, cy - r), min(h, cy + r))\n",
        "    xs = slice(max(0, cx - r), min(w, cx + r))\n",
        "    region = energy_current[ys, xs]\n",
        "    flat = np.argmin(region)\n",
        "    y0 = flat // (region.shape[1]) + (cy - r)\n",
        "    x0 = flat % (region.shape[1]) + (cx - r)\n",
        "\n",
        "    # Place first point\n",
        "    energy_current = energy_current + energy_splat(y0, x0)\n",
        "    energy_current[y0, x0] = np.inf  # Prevent reselection\n",
        "    samples.append((y0, x0, I[y0, x0]))\n",
        "    final_stipple[y0, x0] = 0.0  # Black dot\n",
        "\n",
        "    # Iteratively place remaining points\n",
        "    for i in range(1, num_points):\n",
        "        # Add exploration noise that decreases over time\n",
        "        exploration = 1.0 - (i / num_points) * 0.5  # Decrease from 1.0 to 0.5\n",
        "        noise = np.random.normal(0.0, noise_scale_factor * content_bias * exploration, size=energy_current.shape)\n",
        "        energy_with_noise = energy_current + noise\n",
        "\n",
        "        # Find position with minimum energy (with noise for exploration)\n",
        "        pos_flat = np.argmin(energy_with_noise)\n",
        "        y = pos_flat // w\n",
        "        x = pos_flat % w\n",
        "\n",
        "        # Add Gaussian splat to prevent nearby points from being selected\n",
        "        energy_current = energy_current + energy_splat(y, x)\n",
        "        energy_current[y, x] = np.inf  # Prevent reselection\n",
        "\n",
        "        # Record the sample\n",
        "        samples.append((y, x, I[y, x]))\n",
        "        final_stipple[y, x] = 0.0  # Black dot\n",
        "\n",
        "    return final_stipple, np.array(samples)"
      ],
      "id": "stippling-functions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Preparing the Working Image\n",
        "\n",
        "Before generating the stippling pattern, we prepare the image by resizing if necessary and computing the importance map.\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "c900dc59"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: prep-image\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "# Resize image if it's too large for faster processing\n",
        "max_size = 512\n",
        "if img_array.shape[0] > max_size or img_array.shape[1] > max_size:\n",
        "    scale = max_size / max(img_array.shape[0], img_array.shape[1])\n",
        "    new_size = (int(img_array.shape[1] * scale), int(img_array.shape[0] * scale))\n",
        "    img_resized_pil = original_img.resize(new_size, Image.Resampling.LANCZOS)\n",
        "    if img_resized_pil.mode != 'L':\n",
        "        img_resized_pil = img_resized_pil.convert('L')\n",
        "    img_resized = np.array(img_resized_pil, dtype=np.float32) / 255.0\n",
        "    print(f\"Resized image from {img_array.shape} to {img_resized.shape} for processing\")\n",
        "else:\n",
        "    img_resized = img_array.copy()\n",
        "\n",
        "# Ensure img_resized is 2D grayscale\n",
        "if len(img_resized.shape) > 2:\n",
        "    img_resized = img_resized[:, :, 0]\n",
        "elif len(img_resized.shape) == 2:\n",
        "    pass\n",
        "else:\n",
        "    raise ValueError(f\"Unexpected image shape: {img_resized.shape}\")\n",
        "\n",
        "print(f\"Final image shape: {img_resized.shape} (should be 2D for grayscale)\")\n",
        "\n",
        "# Compute importance map using default parameters\n",
        "importance_map = compute_importance(\n",
        "    img_resized,\n",
        "    extreme_downweight=0.5,\n",
        "    extreme_threshold_low=0.2,\n",
        "    extreme_threshold_high=0.8,\n",
        "    extreme_sigma=0.1\n",
        ")\n",
        "print(\"Importance map computed\")"
      ],
      "id": "prep-image",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "## Generating the Stippled Image\n",
        "\n",
        "Now that the image is preprocessed, run the stippling algorithm and display the results side by side.\n",
        "\n",
        ":::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "7d811041"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false,
        "fig-width": 7,
        "fig-height": 4
      },
      "source": [
        "#| label: generate-and-display\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "#| fig-cap: Original image, importance map, and blue noise stippling\n",
        "\n",
        "# Generate stippling pattern\n",
        "print(\"Generating blue noise stippling pattern...\")\n",
        "stipple_pattern, samples = void_and_cluster(\n",
        "    img_resized,\n",
        "    percentage=0.08,\n",
        "    sigma=0.9,\n",
        "    content_bias=0.9,\n",
        "    importance_img=importance_map,\n",
        "    noise_scale_factor=0.1,\n",
        ")\n",
        "\n",
        "print(f\"Generated {len(samples)} stipple points\")\n",
        "print(f\"Stipple pattern shape: {stipple_pattern.shape}\")\n",
        "\n",
        "# Display original image, importance map, and stippled result\n",
        "fig, axes = plt.subplots(1, 3, figsize=(7, 4))\n",
        "\n",
        "axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)\n",
        "axes[0].axis('off')\n",
        "axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)\n",
        "\n",
        "axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)\n",
        "axes[1].axis('off')\n",
        "axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)\n",
        "\n",
        "axes[2].imshow(stipple_pattern, cmap='gray', vmin=0, vmax=1)\n",
        "axes[2].axis('off')\n",
        "axes[2].set_title('Blue Noise Stippling', fontsize=14, fontweight='bold', pad=10)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "generate-and-display",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "::::\n",
        "\n",
        "## Progressive Stippling Animation\n",
        "\n",
        "Now letâ€™s build a GIF that shows the stippling pattern as points accumulate.\n",
        "\n",
        ":::: {.panel-tabset}\n",
        "\n",
        "### Python"
      ],
      "id": "9f340f98"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: progressive-stippling\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "print(f\"Using existing stippling with {len(samples)} points\")\n",
        "print(f\"Image shape: {img_resized.shape}\")\n",
        "\n",
        "frame_increment = 100\n",
        "frames = []\n",
        "point_counts = []\n",
        "\n",
        "h, w = img_resized.shape\n",
        "progressive_stipple = np.ones_like(img_resized)\n",
        "\n",
        "if len(samples) > 0:\n",
        "    y0, x0 = int(samples[0, 0]), int(samples[0, 1])\n",
        "    progressive_stipple[y0, x0] = 0.0\n",
        "    frames.append(progressive_stipple.copy())\n",
        "    point_counts.append(1)\n",
        "\n",
        "for i in range(1, len(samples)):\n",
        "    y, x = int(samples[i, 0]), int(samples[i, 1])\n",
        "    progressive_stipple[y, x] = 0.0\n",
        "    if (i + 1) % frame_increment == 0 or i == len(samples) - 1:\n",
        "        frames.append(progressive_stipple.copy())\n",
        "        point_counts.append(i + 1)\n",
        "\n",
        "print(f\"Generated {len(frames)} frames at counts: {point_counts}\")"
      ],
      "id": "progressive-stippling",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Python"
      ],
      "id": "feb015cf"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false,
        "fig-width": 6,
        "fig-height": 5
      },
      "source": [
        "#| label: create-gif\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "#| fig-cap: Progressive stippling animation\n",
        "\n",
        "from matplotlib.animation import PillowWriter\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(6, 5))\n",
        "ax.axis('off')\n",
        "\n",
        "writer = PillowWriter(fps=2)\n",
        "gif_path = 'progressive_stippling.gif'\n",
        "\n",
        "print(\"Creating GIF animation...\")\n",
        "with writer.saving(fig, gif_path, dpi=100):\n",
        "    for i in range(len(frames)):\n",
        "        ax.clear()\n",
        "        ax.axis('off')\n",
        "        ax.imshow(frames[i], cmap='gray', vmin=0, vmax=1)\n",
        "        ax.set_title(f'Progressive Stippling: {point_counts[i]} points', fontsize=14, fontweight='bold', pad=10)\n",
        "        writer.grab_frame()\n",
        "\n",
        "plt.close(fig)\n",
        "print(f\"GIF saved to: {gif_path}\")"
      ],
      "id": "create-gif",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Python"
      ],
      "id": "60689738"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: display-gif\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "from IPython.display import Image as IPyImage\n",
        "\n",
        "IPyImage(filename='progressive_stippling.gif')"
      ],
      "id": "display-gif",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Progressive stippling animation showing the cumulative dot placement.](progressive_stippling.gif)\n",
        "\n",
        "::::\n",
        "\n",
        "::::"
      ],
      "id": "d4b43561"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}